--- postfix-2.11.1.orig/makedefs
+++ postfix-2.11.1/makedefs
@@ -308,11 +308,18 @@
 			exit 1
 		    fi
 		    SYSLIBS="-ldb"
+		    SEARCHDIRS=$(${CC-gcc} -print-search-dirs 2>/dev/null |
+			    sed -n '/^libraries: =/s/libraries: =//p' |
+			    sed -e 's/:/\n/g' | xargs -n1 readlink -f |
+			    grep -v 'gcc\|/[0-9.]\+$' | sort -u)
+		    if [ -z "$SEARCHDIRS" ]; then
+			    SEARCHDIRS="/usr/lib64 /lib64 /usr/lib /lib"
+		    fi
 		    ;;
 		esac
 		for name in nsl resolv $GDBM_LIBS
 		do
-		    for lib in /usr/lib64 /lib64 /usr/lib /lib
+		    for lib in $SEARCHDIRS
 		    do
 			test -e $lib/lib$name.a -o -e $lib/lib$name.so && {
 			    SYSLIBS="$SYSLIBS -l$name"
@@ -380,11 +387,18 @@
 			exit 1
 		    fi
 		    SYSLIBS="-ldb"
+		    SEARCHDIRS=$(${CC-gcc} -print-search-dirs 2>/dev/null |
+			    sed -n '/^libraries: =/s/libraries: =//p' |
+			    sed -e 's/:/\n/g' | xargs -n1 readlink -f |
+			    grep -v 'gcc\|/[0-9.]\+$' | sort -u)
+		    if [ -z "$SEARCHDIRS" ]; then
+			    SEARCHDIRS="/usr/lib64 /lib64 /usr/lib /lib"
+		    fi
 		    ;;
 		esac
 		for name in nsl resolv
 		do
-		    for lib in /usr/lib64 /lib64 /usr/lib /usr/lib/* /lib /lib/*
+		    for lib in $SEARCHDIRS
 		    do
 			test -e $lib/lib$name.a -o -e $lib/lib$name.so && {
 			    SYSLIBS="$SYSLIBS -l$name"
@@ -393,8 +407,8 @@
 		    done
 		done
 		;;
-     GNU.0*|GNU/kFreeBSD.[567]*)
-		SYSTYPE=GNU0
+     GNU.0*|GNU/kFreeBSD.*)
+     		SYSTYPE=GNU0
 		case "$CCARGS" in
 		 *-DNO_DB*) ;;
 		 *) if [ -f /usr/include/db.h ]
@@ -411,11 +425,18 @@
 			exit 1
 		    fi
 		    SYSLIBS="-ldb"
+		    SEARCHDIRS=$(${CC-gcc} -print-search-dirs 2>/dev/null |
+			    sed -n '/^libraries: =/s/libraries: =//p' |
+			    sed -e 's/:/\n/g' | xargs -n1 readlink -f |
+			    grep -v 'gcc\|/[0-9.]\+$' | sort -u)
+		    if [ -z "$SEARCHDIRS" ]; then
+			    SEARCHDIRS="/usr/lib64 /lib64 /usr/lib /lib"
+		    fi
 		    ;;
 		esac
 		for name in nsl resolv
 		do
-		    for lib in /usr/lib64 /lib64 /usr/lib /lib
+		    for lib in $SEARCHDIRS
 		    do
 			test -e $lib/lib$name.a -o -e $lib/lib$name.so && {
 			    SYSLIBS="$SYSLIBS -l$name"
--- postfix-2.11.1.orig/Makefile.in
+++ postfix-2.11.1/Makefile.in
@@ -8,6 +8,7 @@
 	src/pipe src/showq src/postalias src/postcat src/postconf src/postdrop \
 	src/postkick src/postlock src/postlog src/postmap src/postqueue \
 	src/postsuper src/qmqpd src/spawn src/flush src/verify \
+	rmail \
 	src/virtual src/proxymap src/anvil src/scache src/discard src/tlsmgr \
 	src/postmulti src/postscreen src/dnsblog src/tlsproxy \
 	src/posttls-finger
--- postfix-2.11.1.orig/examples/smtpd-policy/greylist.pl
+++ postfix-2.11.1/examples/smtpd-policy/greylist.pl
@@ -73,7 +73,7 @@
 # In case of database corruption, this script saves the database as
 # $database_name.time(), so that the mail system does not get stuck.
 #
-$database_name="/var/mta/greylist.db";
+$database_name="/var/lib/postfix/greylist.db";
 $greylist_delay=60;
 
 #
--- postfix-2.11.1.orig/conf/postfix-script
+++ postfix-2.11.1/conf/postfix-script
@@ -42,6 +42,13 @@
 FATAL="$LOGGER -p fatal"
 PANIC="$LOGGER -p panic"
 
+if [ "X${1#quiet-}" != "X${1}" ]; then
+    INFO=:
+    x=${1#quiet-}
+    shift
+    set -- $x "$@"
+fi
+
 umask 022
 SHELL=/bin/sh
 
@@ -106,6 +113,20 @@
 	echo "Stop postfix"
 	;;
 
+quick-start)
+
+	$daemon_directory/master -t 2>/dev/null || {
+		$FATAL the Postfix mail system is already running
+		exit 1
+	}
+	$daemon_directory/postfix-script quick-check || {
+		$FATAL Postfix integrity check failed!
+		exit 1
+	}
+	$INFO starting the Postfix mail system
+	$daemon_directory/master &
+	;;
+
 start)
 
 	$daemon_directory/master -t 2>/dev/null || {
@@ -151,7 +172,7 @@
 
 	$daemon_directory/master -t 2>/dev/null && {
 		$FATAL the Postfix mail system is not running
-		exit 1
+		exit 0
 	}
 	$INFO stopping the Postfix mail system
 	kill `sed 1q pid/master.pid`
@@ -170,7 +191,7 @@
 
 	$daemon_directory/master -t 2>/dev/null && {
 		$FATAL the Postfix mail system is not running
-		exit 1
+		exit 0
 	}
 	$INFO aborting the Postfix mail system
 	kill `sed 1q pid/master.pid`
@@ -214,12 +235,11 @@
 	exit 0
 	;;
 
-
-check-fatal)
+quick-check)
 	# This command is NOT part of the public interface.
 
 	$SHELL $daemon_directory/post-install create-missing || {
-		$FATAL unable to create missing queue directories
+		$WARN unable to create missing queue directories
 		exit 1
 	}
 
@@ -229,6 +249,13 @@
 		$FATAL no $config_directory/master.cf file found
 		exit 1
 	}
+	exit 0
+	;;
+
+check-fatal)
+	# This command is NOT part of the public interface.
+
+	$daemon_directory/postfix-script quick-check
 
 	# See if all queue files are in the right place. This is slow.
 	# We must scan all queues for mis-named queue files before the
--- postfix-2.11.1.orig/conf/master.cf
+++ postfix-2.11.1/conf/master.cf
@@ -9,12 +9,12 @@
 # service type  private unpriv  chroot  wakeup  maxproc command + args
 #               (yes)   (yes)   (yes)   (never) (100)
 # ==========================================================================
-smtp      inet  n       -       n       -       -       smtpd
-#smtp      inet  n       -       n       -       1       postscreen
-#smtpd     pass  -       -       n       -       -       smtpd
-#dnsblog   unix  -       -       n       -       0       dnsblog
-#tlsproxy  unix  -       -       n       -       0       tlsproxy
-#submission inet n       -       n       -       -       smtpd
+smtp      inet  n       -       -       -       -       smtpd
+#smtp      inet  n       -       -       -       1       postscreen
+#smtpd     pass  -       -       -       -       -       smtpd
+#dnsblog   unix  -       -       -       -       0       dnsblog
+#tlsproxy  unix  -       -       -       -       0       tlsproxy
+#submission inet n       -       -       -       -       smtpd
 #  -o syslog_name=postfix/submission
 #  -o smtpd_tls_security_level=encrypt
 #  -o smtpd_sasl_auth_enable=yes
@@ -25,7 +25,7 @@
 #  -o smtpd_recipient_restrictions=
 #  -o smtpd_relay_restrictions=permit_sasl_authenticated,reject
 #  -o milter_macro_daemon_name=ORIGINATING
-#smtps     inet  n       -       n       -       -       smtpd
+#smtps     inet  n       -       -       -       -       smtpd
 #  -o syslog_name=postfix/smtps
 #  -o smtpd_tls_wrappermode=yes
 #  -o smtpd_sasl_auth_enable=yes
@@ -36,32 +36,32 @@
 #  -o smtpd_recipient_restrictions=
 #  -o smtpd_relay_restrictions=permit_sasl_authenticated,reject
 #  -o milter_macro_daemon_name=ORIGINATING
-#628       inet  n       -       n       -       -       qmqpd
-pickup    unix  n       -       n       60      1       pickup
-cleanup   unix  n       -       n       -       0       cleanup
+#628       inet  n       -       -       -       -       qmqpd
+pickup    unix  n       -       -       60      1       pickup
+cleanup   unix  n       -       -       -       0       cleanup
 qmgr      unix  n       -       n       300     1       qmgr
 #qmgr     unix  n       -       n       300     1       oqmgr
-tlsmgr    unix  -       -       n       1000?   1       tlsmgr
-rewrite   unix  -       -       n       -       -       trivial-rewrite
-bounce    unix  -       -       n       -       0       bounce
-defer     unix  -       -       n       -       0       bounce
-trace     unix  -       -       n       -       0       bounce
-verify    unix  -       -       n       -       1       verify
-flush     unix  n       -       n       1000?   0       flush
+tlsmgr    unix  -       -       -       1000?   1       tlsmgr
+rewrite   unix  -       -       -       -       -       trivial-rewrite
+bounce    unix  -       -       -       -       0       bounce
+defer     unix  -       -       -       -       0       bounce
+trace     unix  -       -       -       -       0       bounce
+verify    unix  -       -       -       -       1       verify
+flush     unix  n       -       -       1000?   0       flush
 proxymap  unix  -       -       n       -       -       proxymap
 proxywrite unix -       -       n       -       1       proxymap
-smtp      unix  -       -       n       -       -       smtp
-relay     unix  -       -       n       -       -       smtp
+smtp      unix  -       -       -       -       -       smtp
+relay     unix  -       -       -       -       -       smtp
 #       -o smtp_helo_timeout=5 -o smtp_connect_timeout=5
-showq     unix  n       -       n       -       -       showq
-error     unix  -       -       n       -       -       error
-retry     unix  -       -       n       -       -       error
-discard   unix  -       -       n       -       -       discard
+showq     unix  n       -       -       -       -       showq
+error     unix  -       -       -       -       -       error
+retry     unix  -       -       -       -       -       error
+discard   unix  -       -       -       -       -       discard
 local     unix  -       n       n       -       -       local
 virtual   unix  -       n       n       -       -       virtual
-lmtp      unix  -       -       n       -       -       lmtp
-anvil     unix  -       -       n       -       1       anvil
-scache    unix  -       -       n       -       1       scache
+lmtp      unix  -       -       -       -       -       lmtp
+anvil     unix  -       -       -       -       1       anvil
+scache    unix  -       -       -       -       1       scache
 #
 # ====================================================================
 # Interfaces to non-Postfix software. Be sure to examine the manual
@@ -75,8 +75,8 @@
 # maildrop. See the Postfix MAILDROP_README file for details.
 # Also specify in main.cf: maildrop_destination_recipient_limit=1
 #
-#maildrop  unix  -       n       n       -       -       pipe
-#  flags=DRhu user=vmail argv=/usr/local/bin/maildrop -d ${recipient}
+maildrop  unix  -       n       n       -       -       pipe
+  flags=DRhu user=vmail argv=/usr/bin/maildrop -d ${recipient}
 #
 # ====================================================================
 #
@@ -98,7 +98,6 @@
 #  user=cyrus argv=/cyrus/bin/deliver -e -r ${sender} -m ${extension} ${user}
 #
 # ====================================================================
-#
 # Old example of delivery via Cyrus.
 #
 #old-cyrus unix  -       n       n       -       -       pipe
@@ -108,23 +107,18 @@
 #
 # See the Postfix UUCP_README file for configuration details.
 #
-#uucp      unix  -       n       n       -       -       pipe
-#  flags=Fqhu user=uucp argv=uux -r -n -z -a$sender - $nexthop!rmail ($recipient)
-#
-# ====================================================================
+uucp      unix  -       n       n       -       -       pipe
+  flags=Fqhu user=uucp argv=uux -r -n -z -a$sender - $nexthop!rmail ($recipient)
 #
 # Other external delivery methods.
 #
-#ifmail    unix  -       n       n       -       -       pipe
-#  flags=F user=ftn argv=/usr/lib/ifmail/ifmail -r $nexthop ($recipient)
-#
-#bsmtp     unix  -       n       n       -       -       pipe
-#  flags=Fq. user=bsmtp argv=/usr/local/sbin/bsmtp -f $sender $nexthop $recipient
-#
-#scalemail-backend unix -       n       n       -       2       pipe
-#  flags=R user=scalemail argv=/usr/lib/scalemail/bin/scalemail-store
-#  ${nexthop} ${user} ${extension}
-#
-#mailman   unix  -       n       n       -       -       pipe
-#  flags=FR user=list argv=/usr/lib/mailman/bin/postfix-to-mailman.py
-#  ${nexthop} ${user}
+ifmail    unix  -       n       n       -       -       pipe
+  flags=F user=ftn argv=/usr/lib/ifmail/ifmail -r $nexthop ($recipient)
+bsmtp     unix  -       n       n       -       -       pipe
+  flags=Fq. user=bsmtp argv=/usr/lib/bsmtp/bsmtp -t$nexthop -f$sender $recipient
+scalemail-backend unix	-	n	n	-	2	pipe
+  flags=R user=scalemail argv=/usr/lib/scalemail/bin/scalemail-store ${nexthop} ${user} ${extension}
+mailman   unix  -       n       n       -       -       pipe
+  flags=FR user=list argv=/usr/lib/mailman/bin/postfix-to-mailman.py
+  ${nexthop} ${user}
+
--- postfix-2.11.1.orig/conf/main.cf.tls
+++ postfix-2.11.1/conf/main.cf.tls
@@ -0,0 +1,11 @@
+
+# TLS parameters
+smtpd_tls_cert_file=/etc/ssl/certs/ssl-cert-snakeoil.pem
+smtpd_tls_key_file=/etc/ssl/private/ssl-cert-snakeoil.key
+smtpd_use_tls=yes
+smtpd_tls_session_cache_database = btree:${data_directory}/smtpd_scache
+smtp_tls_session_cache_database = btree:${data_directory}/smtp_scache
+
+# See /usr/share/doc/postfix/TLS_README.gz in the postfix-doc package for
+# information on enabling SSL in the smtp client.
+
--- postfix-2.11.1.orig/conf/main.cf
+++ postfix-2.11.1/conf/main.cf
@@ -28,7 +28,7 @@
 # See the files in examples/chroot-setup for setting up Postfix chroot
 # environments on different UNIX systems.
 #
-queue_directory = /var/spool/postfix
+#queue_directory = /var/spool/postfix
 
 # The command_directory parameter specifies the location of all
 # postXXX commands.
@@ -39,7 +39,7 @@
 # daemon programs (i.e. programs listed in the master.cf file). This
 # directory must be owned by root.
 #
-daemon_directory = /usr/libexec/postfix
+daemon_directory = /usr/lib/postfix
 
 # The data_directory parameter specifies the location of Postfix-writable
 # data files (caches, random numbers). This directory must be owned
@@ -56,7 +56,7 @@
 # particular, don't specify nobody or daemon. PLEASE USE A DEDICATED
 # USER.
 #
-mail_owner = postfix
+#mail_owner = postfix
 
 # The default_privs parameter specifies the default rights used by
 # the local delivery agent for delivery to external file or command.
@@ -95,6 +95,11 @@
 # myorigin also specifies the default domain name that is appended
 # to recipient addresses that have no @domain part.
 #
+# Debian GNU/Linux specific:  Specifying a file name will cause the
+# first line of that file to be used as the name.  The Debian default
+# is /etc/mailname.
+#
+#myorigin = /etc/mailname
 #myorigin = $myhostname
 #myorigin = $mydomain
 
@@ -260,6 +265,7 @@
 #mynetworks = 168.100.189.0/28, 127.0.0.0/8
 #mynetworks = $config_directory/mynetworks
 #mynetworks = hash:/etc/postfix/network_table
+mynetworks = 127.0.0.0/8
 
 # The relay_domains parameter restricts what destinations this system will
 # relay mail to.  See the smtpd_recipient_restrictions description in
@@ -440,8 +446,8 @@
 # IF YOU USE THIS TO DELIVER MAIL SYSTEM-WIDE, YOU MUST SET UP AN
 # ALIAS THAT FORWARDS MAIL FOR ROOT TO A REAL USER.
 #
-#mailbox_command = /some/where/procmail
-#mailbox_command = /some/where/procmail -a "$EXTENSION"
+#mailbox_command = /usr/bin/procmail
+#mailbox_command = /usr/bin/procmail -a "$EXTENSION"
 
 # The mailbox_transport specifies the optional transport in master.cf
 # to use after processing aliases and .forward files. This parameter
@@ -548,6 +554,8 @@
 #
 #smtpd_banner = $myhostname ESMTP $mail_name
 #smtpd_banner = $myhostname ESMTP $mail_name ($mail_version)
+smtpd_banner = $myhostname ESMTP $mail_name (@@DISTRO@@)
+
 
 # PARALLEL DELIVERY TO THE SAME DESTINATION
 #
@@ -572,7 +580,7 @@
 # logging level when an SMTP client or server host name or address
 # matches a pattern in the debug_peer_list parameter.
 #
-debug_peer_level = 2
+#debug_peer_level = 2
 
 # The debug_peer_list parameter specifies an optional list of domain
 # or network patterns, /file/name patterns or type:name tables. When
--- postfix-2.11.1.orig/conf/postfix-files
+++ postfix-2.11.1/conf/postfix-files
@@ -65,6 +65,13 @@
 $queue_directory/trace:d:$mail_owner:-:700:ucr
 $daemon_directory/anvil:f:root:-:755
 $daemon_directory/bounce:f:root:-:755
+$daemon_directory/dict_cdb.so:f:root:-:755
+$daemon_directory/dict_ldap.so:f:root:-:755
+$daemon_directory/dict_pcre.so:f:root:-:755
+$daemon_directory/dict_mysql.so:f:root:-:755
+$daemon_directory/dict_sqlite.so:f:root:-:755
+$daemon_directory/dict_tcp.so:f:root:-:755
+$daemon_directory/dict_sdbm.so:f:root:-:755
 $daemon_directory/cleanup:f:root:-:755
 $daemon_directory/discard:f:root:-:755
 $daemon_directory/dnsblog:f:root:-:755
@@ -97,6 +104,11 @@
 $daemon_directory/trivial-rewrite:f:root:-:755
 $daemon_directory/verify:f:root:-:755
 $daemon_directory/virtual:f:root:-:755
+/usr/lib/libpostfix-dns.so.1:f:root:-:755
+/usr/lib/libpostfix-global.so.1:f:root:-:755
+/usr/lib/libpostfix-tls.so.1:f:root:-:755
+/usr/lib/libpostfix-master.so.1:f:root:-:755
+/usr/lib/libpostfix-util.so.1:f:root:-:755
 $daemon_directory/nqmgr:h:$daemon_directory/qmgr
 $daemon_directory/lmtp:h:$daemon_directory/smtp
 $command_directory/postalias:f:root:-:755
@@ -120,6 +132,7 @@
 $config_directory/aliases:f:root:-:644:p1
 $config_directory/bounce.cf.default:f:root:-:644:1
 $config_directory/canonical:f:root:-:644:p1
+$config_directory/dynamicmaps.cf:f:root:-:644:p1
 $config_directory/cidr_table:f:root:-:644:o
 $config_directory/generic:f:root:-:644:p1
 $config_directory/generics:f:root:-:644:o
--- postfix-2.11.1.orig/src/global/dict_ldap.c
+++ postfix-2.11.1/src/global/dict_ldap.c
@@ -1663,7 +1663,7 @@
     /*
      * Define LDAP Protocol Version.
      */
-    dict_ldap->version = cfg_get_int(dict_ldap->parser, "version", 2, 2, 0);
+    dict_ldap->version = cfg_get_int(dict_ldap->parser, "version", 3, 2, 0);
     switch (dict_ldap->version) {
     case 2:
 	dict_ldap->version = LDAP_VERSION2;
@@ -1672,9 +1672,9 @@
 	dict_ldap->version = LDAP_VERSION3;
 	break;
     default:
-	msg_warn("%s: %s Unknown version %d, using 2.", myname, ldapsource,
+	msg_warn("%s: %s Unknown version %d, using 3.", myname, ldapsource,
 		 dict_ldap->version);
-	dict_ldap->version = LDAP_VERSION2;
+	dict_ldap->version = LDAP_VERSION3;
     }
 
 #if defined(LDAP_API_FEATURE_X_OPENLDAP)
--- postfix-2.11.1.orig/src/global/mail_params.c
+++ postfix-2.11.1/src/global/mail_params.c
@@ -160,6 +160,7 @@
 #include <grp.h>
 #include <time.h>
 #include <ctype.h>
+#include <netdb.h>
 
 #ifdef STRCASECMP_IN_STRINGS_H
 #include <strings.h>
@@ -322,7 +323,6 @@
 static const char *check_myhostname(void)
 {
     static const char *name;
-    const char *dot;
     const char *domain;
 
     /*
@@ -336,10 +336,17 @@
      * contents of $mydomain. Use a default domain as a final workaround.
      */
     name = get_hostname();
-    if ((dot = strchr(name, '.')) == 0) {
-	if ((domain = mail_conf_lookup_eval(VAR_MYDOMAIN)) == 0)
-	    domain = DEF_MYDOMAIN;
-	name = concatenate(name, ".", domain, (char *) 0);
+    if (strchr(name, '.') == 0) {
+       /* This may or may not be the most intelligent possible method,
+          but it is what Debian 'hostname --fqdn' does. */
+	struct hostent *ent = gethostbyname(name);
+	if (ent)
+	    name = strdup(ent->h_name);
+	if (strchr(name, '.') == 0) {
+	    if ((domain = mail_conf_lookup_eval(VAR_MYDOMAIN)) == 0)
+		domain = DEF_MYDOMAIN;
+	    name = concatenate(name, ".", domain, (char *) 0);
+	}
     }
     return (name);
 }
--- postfix-2.11.1.orig/src/tls/tls_misc.c
+++ postfix-2.11.1/src/tls/tls_misc.c
@@ -931,19 +931,7 @@
 
 void    tls_check_version(void)
 {
-    TLS_VINFO hdr_info;
-    TLS_VINFO lib_info;
-
-    tls_version_split(OPENSSL_VERSION_NUMBER, &hdr_info);
-    tls_version_split(SSLeay(), &lib_info);
-
-    if (lib_info.major != hdr_info.major
-	|| lib_info.minor != hdr_info.minor
-	|| lib_info.micro != hdr_info.micro)
-	msg_warn("run-time library vs. compile-time header version mismatch: "
-	     "OpenSSL %d.%d.%d may not be compatible with OpenSSL %d.%d.%d",
-		 lib_info.major, lib_info.minor, lib_info.micro,
-		 hdr_info.major, hdr_info.minor, hdr_info.micro);
+	/* Debian will change the soname if openssl is ever incompatible. */
 }
 
 /* tls_bug_bits - SSL bug compatibility bits for this OpenSSL version */
--- postfix-2.11.1.orig/src/util/dict_dbm.c
+++ postfix-2.11.1/src/util/dict_dbm.c
@@ -417,6 +417,10 @@
     char   *dbm_path = 0;
     int     lock_fd;
 
+#ifdef HAVE_GDBM
+    msg_fatal("%s: gdbm maps use locking that is incompatible with postfix.  Use a hash map instead.",
+		 path);
+#endif
     /*
      * Let the optimizer worry about eliminating redundant code.
      */
--- postfix-2.11.1.orig/src/util/sdbm.c
+++ postfix-2.11.1/src/util/sdbm.c
@@ -0,0 +1,972 @@
+/*++
+/* NAME
+/*      sdbm 3h
+/* SUMMARY
+/*      SDBM Simple DBM: ndbm work-alike hashed database library
+/* SYNOPSIS
+/*      include "sdbm.h"
+/* DESCRIPTION
+/*	This file includes the public domain SDBM (ndbm work-alike hashed
+/*	database library), based on Per-Aake Larson's Dynamic Hashing
+/*	algorithms. BIT 18 (1978).
+/*	author: oz@nexus.yorku.ca
+/*	status: public domain
+/*	The file has been patched following the advice of Uwe Ohse
+/*	<uwe@ohse.de>:
+/*	--------------------------------------------------------------
+/*	this patch fixes a problem with sdbms .dir file, which arrises when
+/*	a second .dir block is needed for the first time. read() returns 0
+/*	in that case, and the library forgot to initialize that new block.
+/*
+/*	A related problem is that the calculation of db->maxbno is wrong.
+/*	It just appends 4096*BYTESIZ bits, which is not enough except for
+/*	small databases (.dir basically doubles everytime it's too small).
+/*	--------------------------------------------------------------
+/*	According to Uwe Ohse, the patch has also been submitted to the
+/*	author of SDBM. (The 4096*BYTESIZ bits comment may apply with a
+/*	different size for Postfix/TLS, as the patch was sent against the
+/*	original SDBM distributiona and for Postfix/TLS I have changed the
+/*	default sizes.
+/* .nf
+/*--*/
+
+/*
+ * sdbm - ndbm work-alike hashed database library
+ * based on Per-Aake Larson's Dynamic Hashing algorithms. BIT 18 (1978).
+ * author: oz@nexus.yorku.ca
+ * status: public domain.
+ *
+ * core routines
+ */
+
+#include <stdio.h>
+#include <stdlib.h>
+#ifdef WIN32
+#include <io.h>
+#include <errno.h>
+#else
+#include <unistd.h>
+#endif
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <fcntl.h>
+#include <errno.h>
+#include <string.h>
+#ifdef __STDC__
+#include <stddef.h>
+#endif
+#include <mymalloc.h>
+
+#include <sdbm.h>
+
+/*
+ * useful macros
+ */
+#define bad(x)          ((x).dptr == NULL || (x).dsize <= 0)
+#define exhash(item)    sdbm_hash((item).dptr, (item).dsize)
+#define ioerr(db)       ((db)->flags |= DBM_IOERR)
+
+#define OFF_PAG(off)    (long) (off) * PBLKSIZ
+#define OFF_DIR(off)    (long) (off) * DBLKSIZ
+
+static long masks[] =
+{
+    000000000000, 000000000001, 000000000003, 000000000007,
+    000000000017, 000000000037, 000000000077, 000000000177,
+    000000000377, 000000000777, 000000001777, 000000003777,
+    000000007777, 000000017777, 000000037777, 000000077777,
+    000000177777, 000000377777, 000000777777, 000001777777,
+    000003777777, 000007777777, 000017777777, 000037777777,
+    000077777777, 000177777777, 000377777777, 000777777777,
+    001777777777, 003777777777, 007777777777, 017777777777
+};
+
+datum   nullitem =
+{NULL, 0};
+
+typedef struct
+{
+    int     dirf;			/* directory file descriptor */
+    int     pagf;			/* page file descriptor */
+    int     flags;			/* status/error flags, see below */
+    long    maxbno;			/* size of dirfile in bits */
+    long    curbit;			/* current bit number */
+    long    hmask;			/* current hash mask */
+    long    blkptr;			/* current block for nextkey */
+    int     keyptr;			/* current key for nextkey */
+    long    blkno;			/* current page to read/write */
+    long    pagbno;			/* current page in pagbuf */
+    char   *pagbuf;			/* page file block buffer */
+    long    dirbno;			/* current block in dirbuf */
+    char   *dirbuf;			/* directory file block buffer */
+}       DBM;
+
+
+/* ************************* */
+
+/*
+ * sdbm - ndbm work-alike hashed database library
+ * based on Per-Aake Larson's Dynamic Hashing algorithms. BIT 18 (1978).
+ * author: oz@nexus.yorku.ca
+ * status: public domain. keep it that way.
+ *
+ * hashing routine
+ */
+
+/*
+ * polynomial conversion ignoring overflows
+ * [this seems to work remarkably well, in fact better
+ * then the ndbm hash function. Replace at your own risk]
+ * use: 65599   nice.
+ *      65587   even better.
+ */
+static long sdbm_hash (char *str, int len)
+{
+    unsigned long n = 0;
+
+#ifdef DUFF
+#define HASHC   n = *str++ + 65599 * n
+    if (len > 0)
+      {
+	  int     loop = (len + 8 - 1) >> 3;
+
+	  switch (len & (8 - 1))
+	    {
+	    case 0:
+		do
+		  {
+		      HASHC;
+	    case 7:
+		      HASHC;
+	    case 6:
+		      HASHC;
+	    case 5:
+		      HASHC;
+	    case 4:
+		      HASHC;
+	    case 3:
+		      HASHC;
+	    case 2:
+		      HASHC;
+	    case 1:
+		      HASHC;
+		  }
+		while (--loop);
+	    }
+
+      }
+#else
+    while (len--)
+	n = *str++ + 65599 * n;
+#endif
+    return n;
+}
+
+/*
+ * check page sanity:
+ * number of entries should be something
+ * reasonable, and all offsets in the index should be in order.
+ * this could be made more rigorous.
+ */
+static int chkpage (char *pag)
+{
+    int     n;
+    int     off;
+    short  *ino = (short *) pag;
+
+    if ((n = ino[0]) < 0 || n > PBLKSIZ / sizeof (short))
+	        return 0;
+
+    if (n > 0)
+      {
+	  off = PBLKSIZ;
+	  for (ino++; n > 0; ino += 2)
+	    {
+		if (ino[0] > off || ino[1] > off ||
+		    ino[1] > ino[0])
+		    return 0;
+		off = ino[1];
+		n -= 2;
+	    }
+      }
+    return 1;
+}
+
+/*
+ * search for the key in the page.
+ * return offset index in the range 0 < i < n.
+ * return 0 if not found.
+ */
+static int seepair (char *pag, int n, char *key, int siz)
+{
+    int     i;
+    int     off = PBLKSIZ;
+    short  *ino = (short *) pag;
+
+    for (i = 1; i < n; i += 2)
+      {
+	  if (siz == off - ino[i] &&
+	      memcmp (key, pag + ino[i], siz) == 0)
+	      return i;
+	  off = ino[i + 1];
+      }
+    return 0;
+}
+
+#ifdef SEEDUPS
+static int duppair (char *pag, datum key)
+{
+    short  *ino = (short *) pag;
+
+    return ino[0] > 0 && seepair (pag, ino[0], key.dptr, key.dsize) > 0;
+}
+
+#endif
+
+/* ************************* */
+
+/*
+ * sdbm - ndbm work-alike hashed database library
+ * based on Per-Aake Larson's Dynamic Hashing algorithms. BIT 18 (1978).
+ * author: oz@nexus.yorku.ca
+ * status: public domain.
+ *
+ * page-level routines
+ */
+
+/*
+ * page format:
+ *      +------------------------------+
+ * ino  | n | keyoff | datoff | keyoff |
+ *      +------------+--------+--------+
+ *      | datoff | - - - ---->         |
+ *      +--------+---------------------+
+ *      |        F R E E A R E A       |
+ *      +--------------+---------------+
+ *      |  <---- - - - | data          |
+ *      +--------+-----+----+----------+
+ *      |  key   | data     | key      |
+ *      +--------+----------+----------+
+ *
+ * calculating the offsets for free area:  if the number
+ * of entries (ino[0]) is zero, the offset to the END of
+ * the free area is the block size. Otherwise, it is the
+ * nth (ino[ino[0]]) entry's offset.
+ */
+
+static int fitpair (char *pag, int need)
+{
+    int     n;
+    int     off;
+    int     avail;
+    short  *ino = (short *) pag;
+
+    off = ((n = ino[0]) > 0) ? ino[n] : PBLKSIZ;
+    avail = off - (n + 1) * sizeof (short);
+    need += 2 * sizeof (short);
+
+    return need <= avail;
+}
+
+static void putpair (char *pag, datum key, datum val)
+{
+    int     n;
+    int     off;
+    short  *ino = (short *) pag;
+
+    off = ((n = ino[0]) > 0) ? ino[n] : PBLKSIZ;
+/*
+ * enter the key first
+ */
+    off -= key.dsize;
+    (void) memcpy (pag + off, key.dptr, key.dsize);
+    ino[n + 1] = off;
+/*
+ * now the data
+ */
+    off -= val.dsize;
+    (void) memcpy (pag + off, val.dptr, val.dsize);
+    ino[n + 2] = off;
+/*
+ * adjust item count
+ */
+    ino[0] += 2;
+}
+
+static datum getpair (char *pag, datum key)
+{
+    int     i;
+    int     n;
+    datum   val;
+    short  *ino = (short *) pag;
+
+    if ((n = ino[0]) == 0)
+	return nullitem;
+
+    if ((i = seepair (pag, n, key.dptr, key.dsize)) == 0)
+	return nullitem;
+
+    val.dptr = pag + ino[i + 1];
+    val.dsize = ino[i] - ino[i + 1];
+    return val;
+}
+
+static datum getnkey (char *pag, int num)
+{
+    datum   key;
+    int     off;
+    short  *ino = (short *) pag;
+
+    num = num * 2 - 1;
+    if (ino[0] == 0 || num > ino[0])
+	return nullitem;
+
+    off = (num > 1) ? ino[num - 1] : PBLKSIZ;
+
+    key.dptr = pag + ino[num];
+    key.dsize = off - ino[num];
+
+    return key;
+}
+
+static int delpair (char *pag, datum key)
+{
+    int     n;
+    int     i;
+    short  *ino = (short *) pag;
+
+    if ((n = ino[0]) == 0)
+	return 0;
+
+    if ((i = seepair (pag, n, key.dptr, key.dsize)) == 0)
+	return 0;
+/*
+ * found the key. if it is the last entry
+ * [i.e. i == n - 1] we just adjust the entry count.
+ * hard case: move all data down onto the deleted pair,
+ * shift offsets onto deleted offsets, and adjust them.
+ * [note: 0 < i < n]
+ */
+    if (i < n - 1)
+      {
+	  int     m;
+	  char   *dst = pag + (i == 1 ? PBLKSIZ : ino[i - 1]);
+	  char   *src = pag + ino[i + 1];
+	  int     zoo = dst - src;
+
+/*
+ * shift data/keys down
+ */
+	  m = ino[i + 1] - ino[n];
+#ifdef DUFF
+#define MOVB    *--dst = *--src
+	  if (m > 0)
+	    {
+		int     loop = (m + 8 - 1) >> 3;
+
+		switch (m & (8 - 1))
+		  {
+		  case 0:
+		      do
+			{
+			    MOVB;
+		  case 7:
+			    MOVB;
+		  case 6:
+			    MOVB;
+		  case 5:
+			    MOVB;
+		  case 4:
+			    MOVB;
+		  case 3:
+			    MOVB;
+		  case 2:
+			    MOVB;
+		  case 1:
+			    MOVB;
+			}
+		      while (--loop);
+		  }
+	    }
+#else
+	  dst -= m;
+	  src -= m;
+	  memmove (dst, src, m);
+#endif
+/*
+ * adjust offset index up
+ */
+	  while (i < n - 1)
+	    {
+		ino[i] = ino[i + 2] + zoo;
+		i++;
+	    }
+      }
+    ino[0] -= 2;
+    return 1;
+}
+
+static void splpage (char *pag, char *new, long sbit)
+{
+    datum   key;
+    datum   val;
+
+    int     n;
+    int     off = PBLKSIZ;
+    char    cur[PBLKSIZ];
+    short  *ino = (short *) cur;
+
+    (void) memcpy (cur, pag, PBLKSIZ);
+    (void) memset (pag, 0, PBLKSIZ);
+    (void) memset (new, 0, PBLKSIZ);
+
+    n = ino[0];
+    for (ino++; n > 0; ino += 2)
+      {
+	  key.dptr = cur + ino[0];
+	  key.dsize = off - ino[0];
+	  val.dptr = cur + ino[1];
+	  val.dsize = ino[0] - ino[1];
+/*
+ * select the page pointer (by looking at sbit) and insert
+ */
+	  (void) putpair ((exhash (key) & sbit) ? new : pag, key, val);
+
+	  off = ino[1];
+	  n -= 2;
+      }
+}
+
+static int getdbit (DBM * db, long dbit)
+{
+    long    c;
+    long    dirb;
+
+    c = dbit / BYTESIZ;
+    dirb = c / DBLKSIZ;
+
+    if (dirb != db->dirbno)
+      {
+	  int got;
+	  if (lseek (db->dirf, OFF_DIR (dirb), SEEK_SET) < 0
+	      || (got = read(db->dirf, db->dirbuf, DBLKSIZ)) < 0)
+	      return 0;
+	  if (got==0)
+              memset(db->dirbuf,0,DBLKSIZ);
+	  db->dirbno = dirb;
+      }
+
+    return db->dirbuf[c % DBLKSIZ] & (1 << dbit % BYTESIZ);
+}
+
+static int setdbit (DBM * db, long dbit)
+{
+    long    c;
+    long    dirb;
+
+    c = dbit / BYTESIZ;
+    dirb = c / DBLKSIZ;
+
+    if (dirb != db->dirbno)
+      {
+	  int got;
+	  if (lseek (db->dirf, OFF_DIR (dirb), SEEK_SET) < 0
+	      || (got = read(db->dirf, db->dirbuf, DBLKSIZ)) < 0)
+	      return 0;
+	  if (got==0)
+              memset(db->dirbuf,0,DBLKSIZ);
+	  db->dirbno = dirb;
+      }
+
+    db->dirbuf[c % DBLKSIZ] |= (1 << dbit % BYTESIZ);
+
+#if 0
+    if (dbit >= db->maxbno)
+	db->maxbno += DBLKSIZ * BYTESIZ;
+#else
+    if (OFF_DIR((dirb+1))*BYTESIZ > db->maxbno)
+        db->maxbno=OFF_DIR((dirb+1))*BYTESIZ;
+#endif
+
+    if (lseek (db->dirf, OFF_DIR (dirb), SEEK_SET) < 0
+	|| write (db->dirf, db->dirbuf, DBLKSIZ) < 0)
+	return 0;
+
+    return 1;
+}
+
+/*
+ * getnext - get the next key in the page, and if done with
+ * the page, try the next page in sequence
+ */
+static datum getnext (DBM * db)
+{
+    datum   key;
+
+    for (;;)
+      {
+	  db->keyptr++;
+	  key = getnkey (db->pagbuf, db->keyptr);
+	  if (key.dptr != NULL)
+	      return key;
+/*
+ * we either run out, or there is nothing on this page..
+ * try the next one... If we lost our position on the
+ * file, we will have to seek.
+ */
+	  db->keyptr = 0;
+	  if (db->pagbno != db->blkptr++)
+	      if (lseek (db->pagf, OFF_PAG (db->blkptr), SEEK_SET) < 0)
+		  break;
+	  db->pagbno = db->blkptr;
+	  if (read (db->pagf, db->pagbuf, PBLKSIZ) <= 0)
+	      break;
+	  if (!chkpage (db->pagbuf))
+	      break;
+      }
+
+    return ioerr (db), nullitem;
+}
+
+/*
+ * all important binary trie traversal
+ */
+static int getpage (DBM * db, long hash)
+{
+    int     hbit;
+    long    dbit;
+    long    pagb;
+
+    dbit = 0;
+    hbit = 0;
+    while (dbit < db->maxbno && getdbit (db, dbit))
+	dbit = 2 * dbit + ((hash & (1 << hbit++)) ? 2 : 1);
+
+    db->curbit = dbit;
+    db->hmask = masks[hbit];
+
+    pagb = hash & db->hmask;
+/*
+ * see if the block we need is already in memory.
+ * note: this lookaside cache has about 10% hit rate.
+ */
+    if (pagb != db->pagbno)
+      {
+/*
+ * note: here, we assume a "hole" is read as 0s.
+ * if not, must zero pagbuf first.
+ */
+	  if (lseek (db->pagf, OFF_PAG (pagb), SEEK_SET) < 0
+	      || read (db->pagf, db->pagbuf, PBLKSIZ) < 0)
+	      return 0;
+	  if (!chkpage (db->pagbuf))
+	      return 0;
+	  db->pagbno = pagb;
+      }
+    return 1;
+}
+
+/*
+ * makroom - make room by splitting the overfull page
+ * this routine will attempt to make room for SPLTMAX times before
+ * giving up.
+ */
+static int makroom (DBM * db, long hash, int need)
+{
+    long    newp;
+    char    twin[PBLKSIZ];
+    char   *pag = db->pagbuf;
+    char   *new = twin;
+    int     smax = SPLTMAX;
+
+    do
+      {
+/*
+ * split the current page
+ */
+	  (void) splpage (pag, new, db->hmask + 1);
+/*
+ * address of the new page
+ */
+	  newp = (hash & db->hmask) | (db->hmask + 1);
+
+/*
+ * write delay, read avoidence/cache shuffle:
+ * select the page for incoming pair: if key is to go to the new page,
+ * write out the previous one, and copy the new one over, thus making
+ * it the current page. If not, simply write the new page, and we are
+ * still looking at the page of interest. current page is not updated
+ * here, as sdbm_store will do so, after it inserts the incoming pair.
+ */
+	  if (hash & (db->hmask + 1))
+	    {
+		if (lseek (db->pagf, OFF_PAG (db->pagbno), SEEK_SET) < 0
+		    || write (db->pagf, db->pagbuf, PBLKSIZ) < 0)
+		    return 0;
+		db->pagbno = newp;
+		(void) memcpy (pag, new, PBLKSIZ);
+	    }
+	  else if (lseek (db->pagf, OFF_PAG (newp), SEEK_SET) < 0
+		   || write (db->pagf, new, PBLKSIZ) < 0)
+	      return 0;
+
+	  if (!setdbit (db, db->curbit))
+	      return 0;
+/*
+ * see if we have enough room now
+ */
+	  if (fitpair (pag, need))
+	      return 1;
+/*
+ * try again... update curbit and hmask as getpage would have
+ * done. because of our update of the current page, we do not
+ * need to read in anything. BUT we have to write the current
+ * [deferred] page out, as the window of failure is too great.
+ */
+	  db->curbit = 2 * db->curbit +
+	      ((hash & (db->hmask + 1)) ? 2 : 1);
+	  db->hmask |= db->hmask + 1;
+
+	  if (lseek (db->pagf, OFF_PAG (db->pagbno), SEEK_SET) < 0
+	      || write (db->pagf, db->pagbuf, PBLKSIZ) < 0)
+	      return 0;
+
+      }
+    while (--smax);
+/*
+ * if we are here, this is real bad news. After SPLTMAX splits,
+ * we still cannot fit the key. say goodnight.
+ */
+#ifdef BADMESS
+    (void) write (2, "sdbm: cannot insert after SPLTMAX attempts.\n", 44);
+#endif
+    return 0;
+
+}
+
+static SDBM *sdbm_prep (char *dirname, char *pagname, int flags, int mode)
+{
+    SDBM   *db;
+    struct stat dstat;
+
+    if ((db = (SDBM *) mymalloc (sizeof (SDBM))) == NULL)
+	return errno = ENOMEM, (SDBM *) NULL;
+
+    db->flags = 0;
+    db->blkptr = 0;
+    db->keyptr = 0;
+/*
+ * adjust user flags so that WRONLY becomes RDWR,
+ * as required by this package. Also set our internal
+ * flag for RDONLY if needed.
+ */
+    if (flags & O_WRONLY)
+	flags = (flags & ~O_WRONLY) | O_RDWR;
+    else if ((flags & 03) == O_RDONLY)
+	db->flags = DBM_RDONLY;
+#if defined(OS2) || defined(MSDOS) || defined(WIN32)
+    flags |= O_BINARY;
+#endif
+
+/*
+ * Make sure to ignore the O_EXCL option, as the file might exist due
+ * to the locking.
+ */
+    flags &= ~O_EXCL;
+
+/*
+ * open the files in sequence, and stat the dirfile.
+ * If we fail anywhere, undo everything, return NULL.
+ */
+
+    if ((db->pagf = open (pagname, flags, mode)) > -1)
+      {
+	  if ((db->dirf = open (dirname, flags, mode)) > -1)
+	    {
+/*
+ * need the dirfile size to establish max bit number.
+ */
+		if (fstat (db->dirf, &dstat) == 0)
+		  {
+		      /*
+                       * success
+                       */
+		      return db;
+		  }
+		msg_info ("closing dirf");
+		(void) close (db->dirf);
+	    }
+	  msg_info ("closing pagf");
+	  (void) close (db->pagf);
+      }
+    myfree ((char *) db);
+    return (SDBM *) NULL;
+}
+
+static DBM *sdbm_internal_open (SDBM * sdbm)
+{
+    DBM    *db;
+    struct stat dstat;
+
+    if ((db = (DBM *) mymalloc (sizeof (DBM))) == NULL)
+	return errno = ENOMEM, (DBM *) NULL;
+
+    db->flags = sdbm->flags;
+    db->hmask = 0;
+    db->blkptr = sdbm->blkptr;
+    db->keyptr = sdbm->keyptr;
+    db->pagf = sdbm->pagf;
+    db->dirf = sdbm->dirf;
+    db->pagbuf = sdbm->pagbuf;
+    db->dirbuf = sdbm->dirbuf;
+
+/*
+ * need the dirfile size to establish max bit number.
+ */
+    if (fstat (db->dirf, &dstat) == 0)
+      {
+/*
+ * zero size: either a fresh database, or one with a single,
+ * unsplit data page: dirpage is all zeros.
+ */
+	  db->dirbno = (!dstat.st_size) ? 0 : -1;
+	  db->pagbno = -1;
+	  db->maxbno = dstat.st_size * BYTESIZ;
+
+	  (void) memset (db->pagbuf, 0, PBLKSIZ);
+	  (void) memset (db->dirbuf, 0, DBLKSIZ);
+	  return db;
+      }
+    myfree ((char *) db);
+    return (DBM *) NULL;
+}
+
+static void sdbm_internal_close (DBM * db)
+{
+    if (db == NULL)
+	errno = EINVAL;
+    else
+      {
+	  myfree ((char *) db);
+      }
+}
+
+datum   sdbm_fetch (SDBM * sdb, datum key)
+{
+    datum   retval;
+    DBM    *db;
+
+    if (sdb == NULL || bad (key))
+	return errno = EINVAL, nullitem;
+
+    if (!(db = sdbm_internal_open (sdb)))
+	return errno = EINVAL, nullitem;
+
+    if (getpage (db, exhash (key)))
+      {
+	  retval = getpair (db->pagbuf, key);
+	  sdbm_internal_close (db);
+	  return retval;
+      }
+
+    sdbm_internal_close (db);
+
+    return ioerr (sdb), nullitem;
+}
+
+int     sdbm_delete (SDBM * sdb, datum key)
+{
+    int     retval;
+    DBM    *db;
+
+    if (sdb == NULL || bad (key))
+	return errno = EINVAL, -1;
+    if (sdbm_rdonly (sdb))
+	return errno = EPERM, -1;
+
+    if (!(db = sdbm_internal_open (sdb)))
+	return errno = EINVAL, -1;
+
+    if (getpage (db, exhash (key)))
+      {
+	  if (!delpair (db->pagbuf, key))
+	      retval = -1;
+/*
+ * update the page file
+ */
+	  else if (lseek (db->pagf, OFF_PAG (db->pagbno), SEEK_SET) < 0
+		   || write (db->pagf, db->pagbuf, PBLKSIZ) < 0)
+	      retval = ioerr (sdb), -1;
+	  else
+	      retval = 0;
+      }
+    else
+	retval = ioerr (sdb), -1;
+
+    sdbm_internal_close (db);
+
+    return retval;
+}
+
+int     sdbm_store (SDBM * sdb, datum key, datum val, int flags)
+{
+    int     need;
+    int     retval;
+    long    hash;
+    DBM    *db;
+
+    if (sdb == NULL || bad (key))
+	return errno = EINVAL, -1;
+    if (sdbm_rdonly (sdb))
+	return errno = EPERM, -1;
+
+    need = key.dsize + val.dsize;
+/*
+ * is the pair too big (or too small) for this database ??
+ */
+    if (need < 0 || need > PAIRMAX)
+	return errno = EINVAL, -1;
+
+    if (!(db = sdbm_internal_open (sdb)))
+	return errno = EINVAL, -1;
+
+    if (getpage (db, (hash = exhash (key))))
+      {
+/*
+ * if we need to replace, delete the key/data pair
+ * first. If it is not there, ignore.
+ */
+	  if (flags == DBM_REPLACE)
+	      (void) delpair (db->pagbuf, key);
+#ifdef SEEDUPS
+	  else if (duppair (db->pagbuf, key))
+	    {
+		sdbm_internal_close (db);
+		return 1;
+	    }
+#endif
+/*
+ * if we do not have enough room, we have to split.
+ */
+	  if (!fitpair (db->pagbuf, need))
+	      if (!makroom (db, hash, need))
+		{
+		    sdbm_internal_close (db);
+		    return ioerr (db), -1;
+		}
+/*
+ * we have enough room or split is successful. insert the key,
+ * and update the page file.
+ */
+	  (void) putpair (db->pagbuf, key, val);
+
+	  if (lseek (db->pagf, OFF_PAG (db->pagbno), SEEK_SET) < 0
+	      || write (db->pagf, db->pagbuf, PBLKSIZ) < 0)
+	    {
+		sdbm_internal_close (db);
+		return ioerr (db), -1;
+	    }
+	  /*
+           * success
+           */
+	  sdbm_internal_close (db);
+	  return 0;
+      }
+
+    sdbm_internal_close (db);
+    return ioerr (sdb), -1;
+}
+
+/*
+ * the following two routines will break if
+ * deletions aren't taken into account. (ndbm bug)
+ */
+datum   sdbm_firstkey (SDBM * sdb)
+{
+    datum   retval;
+    DBM    *db;
+
+    if (sdb == NULL)
+	return errno = EINVAL, nullitem;
+
+    if (!(db = sdbm_internal_open (sdb)))
+	return errno = EINVAL, nullitem;
+
+/*
+ * start at page 0
+ */
+    if (lseek (db->pagf, OFF_PAG (0), SEEK_SET) < 0
+	|| read (db->pagf, db->pagbuf, PBLKSIZ) < 0)
+      {
+	  sdbm_internal_close (db);
+	  return ioerr (sdb), nullitem;
+      }
+    db->pagbno = 0;
+    db->blkptr = 0;
+    db->keyptr = 0;
+
+    retval = getnext (db);
+    sdb->blkptr = db->blkptr;
+    sdb->keyptr = db->keyptr;
+    sdbm_internal_close (db);
+    return retval;
+}
+
+datum   sdbm_nextkey (SDBM * sdb)
+{
+    datum   retval;
+    DBM    *db;
+
+    if (sdb == NULL)
+	return errno = EINVAL, nullitem;
+
+    if (!(db = sdbm_internal_open (sdb)))
+	return errno = EINVAL, nullitem;
+
+    retval = getnext (db);
+    sdb->blkptr = db->blkptr;
+    sdb->keyptr = db->keyptr;
+    sdbm_internal_close (db);
+    return retval;
+}
+
+void    sdbm_close (SDBM * db)
+{
+    if (db == NULL)
+	errno = EINVAL;
+    else
+      {
+	  (void) close (db->dirf);
+	  (void) close (db->pagf);
+	  myfree ((char *) db);
+      }
+}
+
+SDBM   *sdbm_open (char *file, int flags, int mode)
+{
+    SDBM   *db;
+    char   *dirname;
+    char   *pagname;
+    int     n;
+
+    if (file == NULL || !*file)
+	return errno = EINVAL, (SDBM *) NULL;
+/*
+ * need space for two seperate filenames
+ */
+    n = strlen (file) * 2 + strlen (DIRFEXT) + strlen (PAGFEXT) + 2;
+
+    if ((dirname = (char *) mymalloc ((unsigned) n)) == NULL)
+	return errno = ENOMEM, (SDBM *) NULL;
+/*
+ * build the file names
+ */
+    dirname = strcat (strcpy (dirname, file), DIRFEXT);
+    pagname = strcpy (dirname + strlen (dirname) + 1, file);
+    pagname = strcat (pagname, PAGFEXT);
+
+    db = sdbm_prep (dirname, pagname, flags, mode);
+    myfree ((char *) dirname);
+    return db;
+}
+
--- postfix-2.11.1.orig/src/util/sys_defs.h
+++ postfix-2.11.1/src/util/sys_defs.h
@@ -767,6 +767,7 @@
 #define INTERNAL_LOCK   MYFLOCK_STYLE_FCNTL
 #define DEF_MAILBOX_LOCK "fcntl, dotlock"       /* RedHat >= 4.x */
 #define HAS_FSYNC
+#define HAS_SDBM
 #define HAS_DB 
 #define NATIVE_DB_TYPE  "hash"
 #define ALIAS_DB_MAP    DEF_DB_TYPE ":/etc/aliases"
--- postfix-2.11.1.orig/src/util/sdbm.h
+++ postfix-2.11.1/src/util/sdbm.h
@@ -0,0 +1,97 @@
+/*++
+/* NAME
+/*      sdbm 3h
+/* SUMMARY
+/*      SDBM Simple DBM: ndbm work-alike hashed database library
+/* SYNOPSIS
+/*      include "sdbm.h"
+/* DESCRIPTION
+/* .nf
+/*--*/
+
+#ifndef UTIL_SDBM_H
+#define UTIL_SDBM_H
+
+/*
+ * sdbm - ndbm work-alike hashed database library
+ * based on Per-Ake Larson's Dynamic Hashing algorithms. BIT 18 (1978).
+ * author: oz@nexus.yorku.ca
+ * status: public domain.
+ */
+
+#define DUFF    /* go ahead and use the loop-unrolled version */
+
+#include <stdio.h>
+
+#define DBLKSIZ 16384                   /* SSL cert chains require more */
+#define PBLKSIZ 8192                    /* SSL cert chains require more */
+#define PAIRMAX 8008                    /* arbitrary on PBLKSIZ-N */
+#define SPLTMAX 10                      /* maximum allowed splits */
+                                        /* for a single insertion */
+#define DIRFEXT ".dir"
+#define PAGFEXT ".pag"
+
+typedef struct {
+        int dirf;                      /* directory file descriptor */
+        int pagf;                      /* page file descriptor */
+        int flags;                     /* status/error flags, see below */
+        long blkptr;                   /* current block for nextkey */
+        int keyptr;                    /* current key for nextkey */
+        char pagbuf[PBLKSIZ];          /* page file block buffer */
+        char dirbuf[DBLKSIZ];          /* directory file block buffer */
+} SDBM;
+
+#define DBM_RDONLY      0x1            /* data base open read-only */
+#define DBM_IOERR       0x2            /* data base I/O error */
+
+/*
+ * utility macros
+ */
+#define sdbm_rdonly(db)         ((db)->flags & DBM_RDONLY)
+#define sdbm_error(db)          ((db)->flags & DBM_IOERR)
+
+#define sdbm_clearerr(db)       ((db)->flags &= ~DBM_IOERR)  /* ouch */
+
+#define sdbm_dirfno(db) ((db)->dirf)
+#define sdbm_pagfno(db) ((db)->pagf)
+
+typedef struct {
+        char *dptr;
+        int dsize;
+} datum;
+
+extern datum nullitem;
+
+/*
+ * flags to sdbm_store
+ */
+#define DBM_INSERT      0
+#define DBM_REPLACE     1
+
+/*
+ * ndbm interface
+ */
+extern SDBM *sdbm_open(char *, int, int);
+extern void sdbm_close(SDBM *);
+extern datum sdbm_fetch(SDBM *, datum);
+extern int sdbm_delete(SDBM *, datum);
+extern int sdbm_store(SDBM *, datum, datum, int);
+extern datum sdbm_firstkey(SDBM *);
+extern datum sdbm_nextkey(SDBM *);
+
+/*
+ * sdbm - ndbm work-alike hashed database library
+ * tuning and portability constructs [not nearly enough]
+ * author: oz@nexus.yorku.ca
+ */
+
+#define BYTESIZ         8
+
+/*
+ * important tuning parms (hah)
+ */
+
+#define SEEDUPS                 /* always detect duplicates */
+#define BADMESS                 /* generate a message for worst case:
+                                   cannot make room after SPLTMAX splits */
+#endif /* UTIL_SDBM_H */
--- postfix-2.11.1.orig/src/xsasl/xsasl_cyrus_client.c
+++ postfix-2.11.1/src/xsasl/xsasl_cyrus_client.c
@@ -224,6 +224,9 @@
      */
     static sasl_callback_t callbacks[] = {
 	{SASL_CB_LOG, (XSASL_CYRUS_CB) &xsasl_cyrus_log, 0},
+#ifdef SASL_CB_GETCONFPATH
+	{SASL_CB_GETCONFPATH,&xsasl_getconfpath, 0},
+#endif
 	{SASL_CB_LIST_END, 0, 0}
     };
 
--- postfix-2.11.1.orig/src/xsasl/xsasl_cyrus_log.c
+++ postfix-2.11.1/src/xsasl/xsasl_cyrus_log.c
@@ -28,10 +28,16 @@
 /* System library. */
 
 #include <sys_defs.h>
+#include <string.h>
 
 /* Utility library. */
 
 #include <msg.h>
+#include <stringops.h>
+
+/* Global library. */
+
+#include <mail_params.h>
 
 /* Application-specific */
 
@@ -101,4 +107,22 @@
     return (SASL_OK);
 }
 
+int xsasl_getpath(void * context, char ** path)
+{
+#if SASL_VERSION_MAJOR >= 2
+    *path = concatenate(var_config_dir, "/", "sasl:/usr/lib/sasl2", (char *) 0);
+#else
+    *path = concatenate(var_config_dir, "/", "sasl:/usr/lib/sasl", (char *) 0);
+#endif
+    return SASL_OK;
+}
+
+#ifdef SASL_CB_GETCONFPATH
+int xsasl_getconfpath(void * context, char ** path)
+{
+    *path = concatenate(var_config_dir, "/", "sasl:/usr/lib/sasl", (char *) 0);
+    return SASL_OK;
+}
+#endif
+
 #endif
--- postfix-2.11.1.orig/src/xsasl/xsasl_cyrus_server.c
+++ postfix-2.11.1/src/xsasl/xsasl_cyrus_server.c
@@ -171,6 +171,9 @@
 
 static sasl_callback_t callbacks[] = {
     {SASL_CB_LOG, (XSASL_CYRUS_CB) &xsasl_cyrus_log, NO_CALLBACK_CONTEXT},
+#ifdef SASL_CB_GETCONFPATH
+    {SASL_CB_GETCONFPATH,&xsasl_getconfpath, 0},
+#endif
     {SASL_CB_LIST_END, 0, 0}
 };
 
--- postfix-2.11.1.orig/src/xsasl/xsasl_cyrus_common.h
+++ postfix-2.11.1/src/xsasl/xsasl_cyrus_common.h
@@ -16,12 +16,18 @@
   */
 #if defined(USE_SASL_AUTH) && defined(USE_CYRUS_SASL)
 
+#include <sasl.h>
+
 #define NO_SASL_LANGLIST	((const char *) 0)
 #define NO_SASL_OUTLANG		((const char **) 0)
 #define xsasl_cyrus_strerror(status) \
 	sasl_errstring((status), NO_SASL_LANGLIST, NO_SASL_OUTLANG)
 extern int xsasl_cyrus_log(void *, int, const char *);
 extern int xsasl_cyrus_security_parse_opts(const char *);
+extern int xsasl_getpath(void * context, char ** path);
+#ifdef SASL_CB_GETCONFPATH
+extern int xsasl_getconfpath(void * context, char ** path);
+#endif
 
 #endif
 
--- postfix-2.11.1.orig/src/postconf/postconf_builtin.c
+++ postfix-2.11.1/src/postconf/postconf_builtin.c
@@ -36,6 +36,7 @@
 
 #include <sys_defs.h>
 #include <string.h>
+#include <netdb.h>
 
 #ifdef USE_PATHS_H
 #include <paths.h>
@@ -176,7 +177,6 @@
 static const char *pcf_check_myhostname(void)
 {
     static const char *name;
-    const char *dot;
     const char *domain;
 
     /*
@@ -187,13 +187,20 @@
 
     /*
      * If the local machine name is not in FQDN form, try to append the
-     * contents of $mydomain.
+     * contents of $mydomain. Use a default domain as a final workaround.
      */
     name = get_hostname();
-    if ((dot = strchr(name, '.')) == 0) {
-	if ((domain = mail_conf_lookup_eval(VAR_MYDOMAIN)) == 0)
-	    domain = DEF_MYDOMAIN;
-	name = concatenate(name, ".", domain, (char *) 0);
+    if (strchr(name, '.') == 0) {
+	/* This may or may not be the most intelligent possible method,
+	  but it is what Debian 'hostname --fqdn' does. */
+	struct hostent *ent = gethostbyname(name);
+	if (ent)
+	    name = strdup(ent->h_name);
+	if (strchr(name, '.') == 0) {
+	    if ((domain = mail_conf_lookup_eval(VAR_MYDOMAIN)) == 0)
+		domain = DEF_MYDOMAIN;
+	    name = concatenate(name, ".", domain, (char *) 0);
+	}
     }
     return (name);
 }
--- postfix-2.11.1.orig/rmail/LICENSE
+++ postfix-2.11.1/rmail/LICENSE
@@ -0,0 +1,79 @@
+			     SENDMAIL LICENSE
+
+The following license terms and conditions apply, unless a different
+license is obtained from Sendmail, Inc., 6425 Christie Ave, Fourth Floor,
+Emeryville, CA 94608, or by electronic mail at license@sendmail.com.
+
+License Terms:
+
+Use, Modification and Redistribution (including distribution of any
+modified or derived work) in source and binary forms is permitted only if
+each of the following conditions is met:
+
+1. Redistributions qualify as "freeware" or "Open Source Software" under
+   one of the following terms:
+
+   (a) Redistributions are made at no charge beyond the reasonable cost of
+       materials and delivery.
+
+   (b) Redistributions are accompanied by a copy of the Source Code or by an
+       irrevocable offer to provide a copy of the Source Code for up to three
+       years at the cost of materials and delivery.  Such redistributions
+       must allow further use, modification, and redistribution of the Source
+       Code under substantially the same terms as this license.  For the
+       purposes of redistribution "Source Code" means the complete compilable
+       and linkable source code of sendmail including all modifications.
+
+2. Redistributions of source code must retain the copyright notices as they
+   appear in each source code file, these license terms, and the
+   disclaimer/limitation of liability set forth as paragraph 6 below.
+
+3. Redistributions in binary form must reproduce the Copyright Notice,
+   these license terms, and the disclaimer/limitation of liability set
+   forth as paragraph 6 below, in the documentation and/or other materials
+   provided with the distribution.  For the purposes of binary distribution
+   the "Copyright Notice" refers to the following language:
+   "Copyright (c) 1998-2000 Sendmail, Inc.  All rights reserved."
+
+4. Neither the name of Sendmail, Inc. nor the University of California nor
+   the names of their contributors may be used to endorse or promote
+   products derived from this software without specific prior written
+   permission.  The name "sendmail" is a trademark of Sendmail, Inc.
+
+5. All redistributions must comply with the conditions imposed by the
+   University of California on certain embedded code, whose copyright
+   notice and conditions for redistribution are as follows:
+
+   (a) Copyright (c) 1988, 1993 The Regents of the University of
+       California.  All rights reserved.
+
+   (b) Redistribution and use in source and binary forms, with or without
+       modification, are permitted provided that the following conditions
+       are met:
+
+      (i)   Redistributions of source code must retain the above copyright
+            notice, this list of conditions and the following disclaimer.
+
+      (ii)  Redistributions in binary form must reproduce the above
+            copyright notice, this list of conditions and the following
+            disclaimer in the documentation and/or other materials provided
+            with the distribution.
+
+      (iii) Neither the name of the University nor the names of its
+            contributors may be used to endorse or promote products derived
+            from this software without specific prior written permission.
+
+6. Disclaimer/Limitation of Liability: THIS SOFTWARE IS PROVIDED BY
+   SENDMAIL, INC. AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED
+   WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+   MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN
+   NO EVENT SHALL SENDMAIL, INC., THE REGENTS OF THE UNIVERSITY OF
+   CALIFORNIA OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
+   INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+   NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
+   USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+   ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+   (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+   THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGES.
+
+$Revision: 1.1.2.1 $, Last updated $Date: 2004/12/28 05:34:15 $
--- postfix-2.11.1.orig/rmail/rmail.8
+++ postfix-2.11.1/rmail/rmail.8
@@ -0,0 +1,49 @@
+.\" Copyright (c) 1998, 1999 Sendmail, Inc. and its suppliers.
+.\"	 All rights reserved.
+.\" Copyright (c) 1983, 1990
+.\"	The Regents of the University of California.  All rights reserved.
+.\"
+.\" By using this file, you agree to the terms and conditions set
+.\" forth in the LICENSE file which can be found at the top level of
+.\" the sendmail distribution.
+.\"
+.\"
+.\"	$Id: 10rmail.dpatch,v 1.1.2.1 2004/12/28 05:34:15 lamont Exp $
+.\"
+.TH RMAIL 8 "$Date: 2004/12/28 05:34:15 $"
+.SH NAME
+.B rmail
+\- handle remote mail received via uucp
+.SH SYNOPSIS
+.B rmail
+.I 
+user ...
+.SH DESCRIPTION
+.B Rmail
+interprets incoming mail received via 
+uucp(1), 
+collapsing ``From'' lines in the form generated 
+by 
+mail.local(8) 
+into a single line of the form ``return-path!sender'', 
+and passing the processed mail on to 
+sendmail(8).
+.PP
+.B Rmail
+is explicitly designed for use with 
+uucp 
+and 
+sendmail.
+.SH SEE ALSO
+uucp(1), 
+mail.local(8), 
+sendmail(8)
+.SH HISTORY
+The
+.B rmail
+program appeared in 
+4.2BSD.
+.SH BUGS
+.B Rmail
+should not reside in 
+/bin.
--- postfix-2.11.1.orig/rmail/Makefile.in
+++ postfix-2.11.1/rmail/Makefile.in
@@ -0,0 +1,56 @@
+SHELL	= /bin/sh
+SRCS	= rmail.c
+OBJS	= rmail.o
+HDRS	= 
+TESTSRC	=
+WARN	= -W -Wformat -Wimplicit -Wmissing-prototypes \
+	-Wparentheses -Wstrict-prototypes -Wswitch -Wuninitialized \
+	-Wunused
+DEFS	= -I. -I$(INC_DIR) -D$(SYSTYPE) -DHASSNPRINTF -DHASSTRERROR
+CFLAGS	= $(DEBUG) $(OPT) $(DEFS)
+TESTPROG= 
+PROG	= rmail
+INC_DIR = 
+LIBS	= 
+
+.c.o:;	$(CC) $(CFLAGS) -c $*.c
+
+$(PROG): $(OBJS) $(LIBS)
+	$(CC) $(CFLAGS) -o $@ $(OBJS) $(LIBS) $(SYSLIBS)
+
+Makefile: Makefile.in
+	(set -e; echo "# DO NOT EDIT"; $(OPTS) sh ../makedefs; cat $?) >$@
+
+test:	$(TESTPROG)
+
+update: ../bin/$(PROG)
+
+../bin/$(PROG): $(PROG)
+	cp $(PROG) ../bin
+
+printfck: $(OBJS) $(PROG)
+	rm -rf printfck
+	mkdir printfck
+	sed '1,/^# do not edit/!d' Makefile >printfck/Makefile
+	set -e; for i in *.c; do printfck -f .printfck $$i >printfck/$$i; done
+	cd printfck; make "INC_DIR=../../include" `cd ..; ls *.o`
+
+lint:
+	lint $(DEFS) $(SRCS) $(LINTFIX)
+
+clean:
+	rm -f *.o *core $(PROG) $(TESTPROG) junk 
+	rm -rf printfck
+
+tidy:	clean
+
+depend: $(MAKES)
+	(sed '1,/^# do not edit/!d' Makefile.in; \
+	set -e; for i in [a-z][a-z0-9]*.c; do \
+	    $(CC) -E $(DEFS) $(INCL) $$i | sed -n -e '/^# *1 *"\([^"]*\)".*/{' \
+	    -e 's//'`echo $$i|sed 's/c$$/o/'`': \1/' -e 'p' -e '}'; \
+	done) | grep -v '[.][o][:][ ][/]' >$$$$ && mv $$$$ Makefile.in
+	@make -f Makefile.in Makefile
+
+# do not edit below this line - it is generated by 'make depend'
+rmail.o: rmail.c
--- postfix-2.11.1.orig/rmail/rmail.c
+++ postfix-2.11.1/rmail/rmail.c
@@ -0,0 +1,475 @@
+/*
+ * Copyright (c) 1998-2000 Sendmail, Inc. and its suppliers.
+ *	All rights reserved.
+ * Copyright (c) 1988, 1993
+ *	The Regents of the University of California.  All rights reserved.
+ *
+ * By using this file, you agree to the terms and conditions set
+ * forth in the LICENSE file which can be found at the top level of
+ * the sendmail distribution.
+ *
+ */
+
+#ifndef lint
+static char copyright[] =
+"@(#) Copyright (c) 1998-2000 Sendmail, Inc. and its suppliers.\n\
+	All rights reserved.\n\
+     Copyright (c) 1988, 1993\n\
+	The Regents of the University of California.  All rights reserved.\n";
+#endif /* ! lint */
+
+#ifndef lint
+static char id[] = "@(#)$Id: 10rmail.dpatch,v 1.1.2.1 2004/12/28 05:34:15 lamont Exp $";
+#endif /* ! lint */
+
+/*
+ * RMAIL -- UUCP mail server.
+ *
+ * This program reads the >From ... remote from ... lines that UUCP is so
+ * fond of and turns them into something reasonable.  It then execs sendmail
+ * with various options built from these lines.
+ *
+ * The expected syntax is:
+ *
+ *	 <user> := [-a-z0-9]+
+ *	 <date> := ctime format
+ *	 <site> := [-a-z0-9!]+
+ * <blank line> := "^\n$"
+ *	 <from> := "From" <space> <user> <space> <date>
+ *		  [<space> "remote from" <space> <site>]
+ *    <forward> := ">" <from>
+ *	    msg := <from> <forward>* <blank-line> <body>
+ *
+ * The output of rmail(8) compresses the <forward> lines into a single
+ * from path.
+ *
+ * The err(3) routine is included here deliberately to make this code
+ * a bit more portable.
+ */
+
+#include <sys/types.h>
+#include <sys/param.h>
+#include <sys/stat.h>
+#include <sys/wait.h>
+
+#include <ctype.h>
+#include <fcntl.h>
+#ifdef BSD4_4
+# define FORK vfork
+# include <paths.h>
+#else /* BSD4_4 */
+# define FORK fork
+# ifndef _PATH_SENDMAIL
+#  define _PATH_SENDMAIL "/usr/lib/sendmail"
+# endif /* ! _PATH_SENDMAIL */
+#endif /* BSD4_4 */
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <unistd.h>
+#ifdef EX_OK
+# undef EX_OK		/* unistd.h may have another use for this */
+#endif /* EX_OK */
+#include <sysexits.h>
+
+#ifndef MAX
+# define MAX(a, b)	((a) < (b) ? (b) : (a))
+#endif /* ! MAX */
+
+#ifndef __P
+# ifdef __STDC__
+#  define __P(protos)	protos
+# else /* __STDC__ */
+#  define __P(protos)	()
+#  define const
+# endif /* __STDC__ */
+#endif /* ! __P */
+
+#ifndef STDIN_FILENO
+# define STDIN_FILENO	0
+#endif /* ! STDIN_FILENO */
+
+#if defined(BSD4_4) || defined(linux) || SOLARIS >= 20600 || (SOLARIS < 10000 && SOLARIS >= 206) || _AIX4 >= 40300 || defined(HPUX11)
+# define HASSNPRINTF	1
+#endif /* defined(BSD4_4) || defined(linux) || SOLARIS >= 20600 || (SOLARIS < 10000 && SOLARIS >= 206) || _AIX4 >= 40300 || defined(HPUX11) */
+
+#if defined(sun) && !defined(BSD) && !defined(SOLARIS) && !defined(__svr4__) && !defined(__SVR4)
+# define memmove(d, s, l)	(bcopy((s), (d), (l)))
+#endif /* defined(sun) && !defined(BSD) && !defined(SOLARIS) && !defined(__svr4__) && !defined(__SVR4) */
+
+#if !HASSNPRINTF
+extern int	snprintf __P((char *, size_t, const char *, ...));
+#endif /* !HASSNPRINTF */
+
+#if defined(BSD4_4) || defined(__osf__) || defined(__GNU_LIBRARY__) || defined(IRIX64) || defined(IRIX5) || defined(IRIX6)
+# ifndef HASSTRERROR
+#  define HASSTRERROR	1
+# endif /* ! HASSTRERROR */
+#endif /* defined(BSD4_4) || defined(__osf__) || defined(__GNU_LIBRARY__) ||
+	  defined(IRIX64) || defined(IRIX5) || defined(IRIX6) */
+
+#if defined(SUNOS403) || defined(NeXT) || (defined(MACH) && defined(i386) && !defined(__GNU__)) || defined(oldBSD43) || defined(MORE_BSD) || defined(umipsbsd) || defined(ALTOS_SYSTEM_V) || defined(RISCOS) || defined(_AUX_SOURCE) || defined(UMAXV) || defined(titan) || defined(UNIXWARE) || defined(sony_news) || defined(luna) || defined(nec_ews_svr4) || defined(_nec_ews_svr4) || defined(__MAXION__)
+# undef WIFEXITED
+# undef WEXITSTATUS
+# define WIFEXITED(st)		(((st) & 0377) == 0)
+# define WEXITSTATUS(st)	(((st) >> 8) & 0377)
+#endif /* defined(SUNOS403) || defined(NeXT) || (defined(MACH) && defined(i386) && !defined(__GNU__)) || defined(oldBSD43) || defined(MORE_BSD) || defined(umipsbsd) || defined(ALTOS_SYSTEM_V) || defined(RISCOS) || defined(_AUX_SOURCE) || defined(UMAXV) || defined(titan) || defined(UNIXWARE) || defined(sony_news) || defined(luna) || defined(nec_ews_svr4) || defined(_nec_ews_svr4) || defined(__MAXION__) */
+
+#include <errno.h>
+
+static void err __P((int, const char *, ...));
+static void usage __P((void));
+static char *xalloc __P((int));
+
+#define newstr(s)	strcpy(xalloc(strlen(s) + 1), s)
+
+static char *
+xalloc(sz)
+	register int sz;
+{
+	register char *p;
+
+	/* some systems can't handle size zero mallocs */
+	if (sz <= 0)
+		sz = 1;
+
+	p = malloc((unsigned) sz);
+	if (p == NULL)
+		err(EX_TEMPFAIL, "out of memory");
+	return (p);
+}
+
+int
+main(argc, argv)
+	int argc;
+	char *argv[];
+{
+	int ch, debug, i, pdes[2], pid, status;
+	size_t fplen = 0, fptlen = 0, len;
+	off_t offset;
+	FILE *fp;
+	char *addrp = NULL, *domain, *p, *t;
+	char *from_path, *from_sys, *from_user;
+	char **args, buf[2048], lbuf[2048];
+	struct stat sb;
+	extern char *optarg;
+	extern int optind;
+
+	debug = 0;
+	domain = "UUCP";		/* Default "domain". */
+	while ((ch = getopt(argc, argv, "D:T")) != -1)
+	{
+		switch (ch)
+		{
+		  case 'T':
+			debug = 1;
+			break;
+
+		  case 'D':
+			domain = optarg;
+			break;
+
+		  case '?':
+		  default:
+			usage();
+		}
+	}
+
+	argc -= optind;
+	argv += optind;
+
+	if (argc < 1)
+		usage();
+
+	from_path = from_sys = from_user = NULL;
+	for (offset = 0; ; )
+	{
+		/* Get and nul-terminate the line. */
+		if (fgets(lbuf, sizeof(lbuf), stdin) == NULL)
+			exit(EX_DATAERR);
+		if ((p = strchr(lbuf, '\n')) == NULL)
+			err(EX_DATAERR, "line too long");
+		*p = '\0';
+
+		/* Parse lines until reach a non-"From" line. */
+		if (!strncmp(lbuf, "From ", 5))
+			addrp = lbuf + 5;
+		else if (!strncmp(lbuf, ">From ", 6))
+			addrp = lbuf + 6;
+		else if (offset == 0)
+			err(EX_DATAERR,
+			    "missing or empty From line: %s", lbuf);
+		else
+		{
+			*p = '\n';
+			break;
+		}
+
+		if (addrp == NULL || *addrp == '\0')
+			err(EX_DATAERR, "corrupted From line: %s", lbuf);
+
+		/* Use the "remote from" if it exists. */
+		for (p = addrp; (p = strchr(p + 1, 'r')) != NULL; )
+		{
+			if (!strncmp(p, "remote from ", 12))
+			{
+				for (t = p += 12; *t != '\0'; ++t)
+				{
+					if (isascii(*t) && isspace(*t))
+						break;
+				}
+				*t = '\0';
+				if (debug)
+					fprintf(stderr, "remote from: %s\n", p);
+				break;
+			}
+		}
+
+		/* Else use the string up to the last bang. */
+		if (p == NULL)
+		{
+			if (*addrp == '!')
+				err(EX_DATAERR, "bang starts address: %s",
+				    addrp);
+			else if ((t = strrchr(addrp, '!')) != NULL)
+			{
+				*t = '\0';
+				p = addrp;
+				addrp = t + 1;
+				if (*addrp == '\0')
+					err(EX_DATAERR,
+					    "corrupted From line: %s", lbuf);
+				if (debug)
+					fprintf(stderr, "bang: %s\n", p);
+			}
+		}
+
+		/* 'p' now points to any system string from this line. */
+		if (p != NULL)
+		{
+			/* Nul terminate it as necessary. */
+			for (t = p; *t != '\0'; ++t)
+			{
+				if (isascii(*t) && isspace(*t))
+					break;
+			}
+			*t = '\0';
+
+			/* If the first system, copy to the from_sys string. */
+			if (from_sys == NULL)
+			{
+				from_sys = newstr(p);
+				if (debug)
+					fprintf(stderr, "from_sys: %s\n",
+						from_sys);
+			}
+
+			/* Concatenate to the path string. */
+			len = t - p;
+			if (from_path == NULL)
+			{
+				fplen = 0;
+				if ((from_path = malloc(fptlen = 256)) == NULL)
+					err(EX_TEMPFAIL, NULL);
+			}
+			if (fplen + len + 2 > fptlen)
+			{
+				fptlen += MAX(fplen + len + 2, 256);
+				if ((from_path = realloc(from_path,
+							 fptlen)) == NULL)
+					err(EX_TEMPFAIL, NULL);
+			}
+			memmove(from_path + fplen, p, len);
+			fplen += len;
+			from_path[fplen++] = '!';
+			from_path[fplen] = '\0';
+		}
+
+		/* Save off from user's address; the last one wins. */
+		for (p = addrp; *p != '\0'; ++p)
+		{
+			if (isascii(*p) && isspace(*p))
+				break;
+		}
+		*p = '\0';
+		if (*addrp == '\0')
+			addrp = "<>";
+		if (from_user != NULL)
+			free(from_user);
+		from_user = newstr(addrp);
+
+		if (debug)
+		{
+			if (from_path != NULL)
+				fprintf(stderr, "from_path: %s\n", from_path);
+			fprintf(stderr, "from_user: %s\n", from_user);
+		}
+
+		if (offset != -1)
+			offset = (off_t)ftell(stdin);
+	}
+
+
+	/* Allocate args (with room for sendmail args as well as recipients */
+	args = (char **)xalloc(sizeof(*args) * (10 + argc));
+
+	i = 0;
+	args[i++] = _PATH_SENDMAIL;	/* Build sendmail's argument list. */
+	args[i++] = "-G";		/* relay submission */
+	args[i++] = "-oee";		/* No errors, just status. */
+	args[i++] = "-odq";		/* Queue it, don't try to deliver. */
+	args[i++] = "-oi";		/* Ignore '.' on a line by itself. */
+
+	/* set from system and protocol used */
+	if (from_sys == NULL)
+		snprintf(buf, sizeof(buf), "-p%s", domain);
+	else if (strchr(from_sys, '.') == NULL)
+		snprintf(buf, sizeof(buf), "-p%s:%s.%s",
+			domain, from_sys, domain);
+	else
+		snprintf(buf, sizeof(buf), "-p%s:%s", domain, from_sys);
+	args[i++] = newstr(buf);
+
+	/* Set name of ``from'' person. */
+	snprintf(buf, sizeof(buf), "-f%s%s",
+		 from_path ? from_path : "", from_user);
+	args[i++] = newstr(buf);
+
+	/*
+	**  Don't copy arguments beginning with - as they will be
+	**  passed to sendmail and could be interpreted as flags.
+	**  To prevent confusion of sendmail wrap < and > around
+	**  the address (helps to pass addrs like @gw1,@gw2:aa@bb)
+	*/
+
+	while (*argv != NULL)
+	{
+		if (**argv == '-')
+			err(EX_USAGE, "dash precedes argument: %s", *argv);
+
+		if (strchr(*argv, ',') == NULL || strchr(*argv, '<') != NULL)
+			args[i++] = *argv;
+		else
+		{
+			len = strlen(*argv) + 3;
+			if ((args[i] = malloc(len)) == NULL)
+				err(EX_TEMPFAIL, "Cannot malloc");
+			snprintf(args[i++], len, "<%s>", *argv);
+		}
+		argv++;
+		argc--;
+
+		/* Paranoia check, argc used for args[] bound */
+		if (argc < 0)
+			err(EX_SOFTWARE, "Argument count mismatch");
+	}
+	args[i] = NULL;
+
+	if (debug)
+	{
+		fprintf(stderr, "Sendmail arguments:\n");
+		for (i = 0; args[i] != NULL; i++)
+			fprintf(stderr, "\t%s\n", args[i]);
+	}
+
+	/*
+	**  If called with a regular file as standard input, seek to the right
+	**  position in the file and just exec sendmail.  Could probably skip
+	**  skip the stat, but it's not unreasonable to believe that a failed
+	**  seek will cause future reads to fail.
+	*/
+
+	if (!fstat(STDIN_FILENO, &sb) && S_ISREG(sb.st_mode))
+	{
+		if (lseek(STDIN_FILENO, offset, SEEK_SET) != offset)
+			err(EX_TEMPFAIL, "stdin seek");
+		(void) execv(_PATH_SENDMAIL, args);
+		err(EX_OSERR, "%s", _PATH_SENDMAIL);
+	}
+
+	if (pipe(pdes) < 0)
+		err(EX_OSERR, NULL);
+
+	switch (pid = FORK())
+	{
+	  case -1:				/* Err. */
+		err(EX_OSERR, NULL);
+		/* NOTREACHED */
+
+	  case 0:				/* Child. */
+		if (pdes[0] != STDIN_FILENO)
+		{
+			(void) dup2(pdes[0], STDIN_FILENO);
+			(void) close(pdes[0]);
+		}
+		(void) close(pdes[1]);
+		(void) execv(_PATH_SENDMAIL, args);
+		_exit(127);
+		/* NOTREACHED */
+	}
+
+	if ((fp = fdopen(pdes[1], "w")) == NULL)
+		err(EX_OSERR, NULL);
+	(void) close(pdes[0]);
+
+	/* Copy the file down the pipe. */
+	do
+	{
+		(void) fprintf(fp, "%s", lbuf);
+	} while (fgets(lbuf, sizeof(lbuf), stdin) != NULL);
+
+	if (ferror(stdin))
+		err(EX_TEMPFAIL, "stdin: %s", strerror(errno));
+
+	if (fclose(fp))
+		err(EX_OSERR, NULL);
+
+	if ((waitpid(pid, &status, 0)) == -1)
+		err(EX_OSERR, "%s", _PATH_SENDMAIL);
+
+	if (!WIFEXITED(status))
+		err(EX_OSERR, "%s: did not terminate normally", _PATH_SENDMAIL);
+
+	if (WEXITSTATUS(status))
+		err(status, "%s: terminated with %d (non-zero) status",
+		    _PATH_SENDMAIL, WEXITSTATUS(status));
+	exit(EX_OK);
+	/* NOTREACHED */
+	return EX_OK;
+}
+
+static void
+usage()
+{
+	(void) fprintf(stderr, "usage: rmail [-T] [-D domain] user ...\n");
+	exit(EX_USAGE);
+}
+
+#ifdef __STDC__
+# include <stdarg.h>
+#else /* __STDC__ */
+# include <varargs.h>
+#endif /* __STDC__ */
+
+static void
+#ifdef __STDC__
+err(int eval, const char *fmt, ...)
+#else /* __STDC__ */
+err(eval, fmt, va_alist)
+	int eval;
+	const char *fmt;
+	va_dcl
+#endif /* __STDC__ */
+{
+	va_list ap;
+#ifdef __STDC__
+	va_start(ap, fmt);
+#else /* __STDC__ */
+	va_start(ap);
+#endif /* __STDC__ */
+	(void) fprintf(stderr, "rmail: ");
+	(void) vfprintf(stderr, fmt, ap);
+	va_end(ap);
+	(void) fprintf(stderr, "\n");
+	exit(eval);
+}
